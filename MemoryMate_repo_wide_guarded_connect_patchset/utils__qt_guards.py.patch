--- /dev/null	2026-02-07 17:14:25.524382886 +0000
+++ /mnt/data/mm_mod/utils/qt_guards.py	2026-02-07 17:20:05.012666114 +0000
@@ -0,0 +1,94 @@
+"""Qt safety helpers for worker -> UI signal delivery.
+
+Use these helpers to avoid:
+1) Use-after-free crashes when a widget gets destroyed while a worker signal is in flight.
+2) Stale worker signals being applied to a new UI instance after restart/relaunch.
+
+How to use
+----------
+- On the UI owner (MainWindow, Dialog), define an integer attribute `_ui_generation`.
+  Increment it when you logically restart/reload the UI.
+- When starting a worker, capture `gen = owner._ui_generation`.
+- Connect worker signals using `connect_guarded(signal, owner, gen, slot)`.
+
+The wrapper will:
+- check shiboken6.isValid(owner)
+- check `owner._ui_generation == gen` (if gen is not None)
+- optionally check other widgets passed via `also_check=[...]`
+
+Note: This module is intentionally dependency-light and safe to import from anywhere.
+"""
+
+from __future__ import annotations
+
+from typing import Any, Callable, Iterable, Optional
+import weakref
+
+from PySide6.QtCore import Qt
+import shiboken6
+
+
+def _is_valid(obj: Any) -> bool:
+    """Return True if obj is a live Qt object (or None).
+
+    shiboken6.isValid expects a Qt wrapper. For non-Qt objects, treat as valid.
+    """
+    if obj is None:
+        return True
+    try:
+        return bool(shiboken6.isValid(obj))
+    except Exception:
+        return True
+
+
+def _generation_matches(owner: Any, expected: Optional[int]) -> bool:
+    if expected is None:
+        return True
+    current = getattr(owner, "_ui_generation", None)
+    return current == expected
+
+
+def make_guarded_slot(
+    owner: Any,
+    expected_generation: Optional[int],
+    slot: Callable[..., Any],
+    also_check: Optional[Iterable[Any]] = None,
+) -> Callable[..., Any]:
+    """Wrap a slot with validity and generation checks."""
+
+    owner_ref = weakref.ref(owner)
+    extra = list(also_check or [])
+
+    def _wrapped(*args: Any, **kwargs: Any) -> Any:
+        o = owner_ref()
+        if o is None:
+            return None
+        if not _is_valid(o):
+            return None
+        for w in extra:
+            if w is not None and not _is_valid(w):
+                return None
+        if not _generation_matches(o, expected_generation):
+            return None
+        try:
+            return slot(*args, **kwargs)
+        except RuntimeError:
+            # Common Qt teardown race: "Internal C++ object already deleted".
+            return None
+
+    return _wrapped
+
+
+def connect_guarded(
+    signal: Any,
+    owner: Any,
+    expected_generation: Optional[int],
+    slot: Callable[..., Any],
+    *,
+    also_check: Optional[Iterable[Any]] = None,
+    connection_type: Qt.ConnectionType = Qt.QueuedConnection,
+) -> None:
+    """Connect signal to slot using a guarded wrapper."""
+    wrapped = make_guarded_slot(owner, expected_generation, slot, also_check=also_check)
+    signal.connect(wrapped, connection_type)
+
