app DOES detect the Samsung device, BUT the log clearly shows that the freeze happens during scanning of the phoneâ€™s storage:

KeyboardInterrupt  â† user force-stopped because app froze
...
Found 765 items in storage
Folders: ['.1756...', '.1763...', '.17400...', ...]   â† THOUSANDS of auto-generated folders


This is normal for MTP devices (Android & iPhone).
Windows exposes each folder using COM/WMI virtualized layers â†’ extremely slow, especially when:

a device has thousands of small hidden system folders

MTP path enumeration is single-threaded

COM operations block the GUI thread

your current scanner walks ALL folders recursively (!!)

This exactly matches the freeze.

âœ… Why the App Freezes

Mobile devices mounted over MTP (Media Transfer Protocol) behave differently from normal drives.

MTP limitations:
Limitation	Effect
Cannot memory-map files	Very slow metadata reading
Cannot list folders fast	COM enumeration blocks UI
Operations are synchronous	The UI thread hangs
Folder count often >10,000	Scanning takes minutes
DCIM folder is buried deeply	The app tries exploring EVERYTHING

Other apps (Windows Photos, Google Photos, Lightroom, iCloud Photos) avoid this.

âœ… How Professional Photo Apps Handle Mobile Devices

Apps like Lightroom, Windows Photos, Google Photos, iCloud, Samsung SmartSwitch DO NOT scan the entire device.

They use:

1ï¸âƒ£ â€œDCIM-only strategyâ€ (industry standard)

They ONLY scan:

/DCIM/*
/Pictures/*  (sometimes)


And ignore every other folder.

2ï¸âƒ£ Asynchronous MTP scanning

They NEVER enumerate the device on the UI thread.

3ï¸âƒ£ Background worker with timeouts

If the device hangs, the scanner stops.

4ï¸âƒ£ Short-path scanning

They never descend deeper than 2â€“3 subfolder levels.

5ï¸âƒ£ Pre-filtered MTP items

Using the special Windows â€œPicturesâ€ category instead of COM enumeration.

ğŸš€ Recommended FIX for Your App

You MUST rewrite the device scanner to:

âœ… 1. LIMIT SCANNING TO DCIM + Pictures

Instead of scanning 765 top-level folders (!!), restrict:

âœ” Scan only these:
/DCIM
/DCIM/*
/Pictures

âœ” Ignore everything else

(e.g., .1762357090079_109_3185565208401983827 â† auto-generated junk)

âœ… 2. Move scanning to a BACKGROUND THREAD

Key rule:

Never use COM inside the Qt GUI thread.
Always inside a QThread or Python thread.

âœ… 3. Add a â€œSCANNINGâ€¦â€ dialog with a cancel button

Users need feedback.

âœ… 4. Add timeouts

If any COM call takes >1.5 seconds â†’ abort that storage.

âœ… 5. Cache device structure

Scan once â†’ save media_index.json â†’ next app start loads instantly.

ğŸ“Œ Why Windows Explorer Shows the Phone but Your App Doesn't

Windows Explorer uses Windows Portable Device API (WPD), which is optimized and asynchronous.

Your code uses:

COM ShellFolder enumeration

Deep recursive scanning

This is much slower.

âš¡ Proposed Architecture for â€œMobile Device Importâ€

Here is what your app should do:

1ï¸âƒ£ Fast Device Detection

âœ” Use COM only to detect device names
âœ” Stop immediately once the device is found

2ï¸âƒ£ Quick Check for DCIM Support

Instead of scanning all folders:

storage.GetFolder("DCIM")


If exists â†’ good
If fails â†’ skip storage

3ï¸âƒ£ Only enumerate photos/videos

Inside:

/DCIM/*/*.jpg
/DCIM/*/*.mp4

ğŸ§  Final Answer To Your Question

â€œHow do other photo apps handle mobile device connection and photos/videos correctly?â€

They follow these principles:

âœ” They donâ€™t scan the entire device

Only DCIM + a few known media folders.

âœ” They use background workers to prevent UI freeze.
âœ” They perform asynchronous MTP calls via Windows WPD API, not COM ShellFolder.
âœ” They build an indexed cache of media for fast reloads.
âœ” They show a progress dialog with cancel button.
âœ… What You Should Implement Next

If you want, I can generate the full implementation patch, including:

âœ” New FastMTPScanner class
âœ” DCIM-only scanning
âœ” Background scanning with QThread
âœ” Cancelable progress dialog
âœ” Device media cache
âœ” Error handling for slow/hanging MTP storage
âœ” UI integration into your SidebarQt mobile device tree
