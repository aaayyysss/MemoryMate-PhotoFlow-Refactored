--- a/main_window_qt.py
+++ b/main_window_qt.py
@@ -3761,6 +3761,10 @@
             exe = sys.executable
             args = sys.argv[:]
             cwd = os.getcwd()
+            # Early generation bump, prevents any late callbacks from the old UI from running
+            # while the new process is being spawned.
+            self._closing = True
+            self.bump_ui_generation(reason="restart requested (pre-spawn)")
             from PySide6.QtCore import QProcess
             ok = QProcess.startDetached(exe, args, cwd)
             if not ok:
--- a/controllers/scan_controller.py
+++ b/controllers/scan_controller.py
@@ -39,11 +39,12 @@
     progress_update_signal = Signal(int, str)
 
     def __init__(self, main):
+        self._get_ui_generation = getattr(main, 'get_ui_generation', lambda: 0)
         super().__init__()  # CRITICAL: Initialize QObject
         self.main = main
 
         # Connect signal to handler with QueuedConnection for thread safety
-        self.progress_update_signal.connect(self._on_progress, Qt.ConnectionType.QueuedConnection)
+        connect_guarded(self.progress_update_signal, self._on_progress, Qt.ConnectionType.QueuedConnection, self._get_ui_generation, name='scan_progress')
         self.thread = None
         self.worker = None
         self.db_writer = None
--- a/layouts/google_layout.py
+++ b/layouts/google_layout.py
@@ -193,7 +193,7 @@
         )
         self._page_signals = PhotoPageSignals()
         self._page_signals.count_ready.connect(self._on_page_count_ready)
-        self._page_signals.page_ready.connect(self._on_page_ready)
+        connect_guarded(self._page_signals.page_ready, self._on_page_ready, self._get_ui_generation, name='page_ready')
         self._page_signals.error.connect(self._on_page_error)
         self._paging_total = 0          # total rows from count query
         self._paging_loaded = 0         # rows received so far
--- a/tests/self_test_harness.py
+++ b/tests/self_test_harness.py
@@ -0,0 +1,101 @@
+"""Self-test harness for UI generation gate and restart safety.
+
+Run:
+    python -m tests.self_test_harness
+"""
+
+import sys
+import tempfile
+import time
+from pathlib import Path
+
+from PySide6.QtCore import QEventLoop, QTimer
+from PySide6.QtWidgets import QApplication
+
+from main_window_qt import MainWindow
+from utils.qt_guards import connect_guarded
+
+
+def _wait_until(predicate, timeout_s=20.0, tick_ms=50):
+    deadline = time.time() + timeout_s
+    loop = QEventLoop()
+
+    def _tick():
+        if predicate() or time.time() >= deadline:
+            loop.quit()
+
+    t = QTimer()
+    t.setInterval(tick_ms)
+    t.timeout.connect(_tick)
+    t.start()
+    _tick()
+    loop.exec()
+    t.stop()
+    return predicate()
+
+
+def _make_sample_images(folder: Path, n=6):
+    try:
+        from PIL import Image
+    except Exception:
+        return
+    folder.mkdir(parents=True, exist_ok=True)
+    for i in range(n):
+        img = Image.new("RGB", (256, 256), (i * 30 % 255, i * 60 % 255, i * 90 % 255))
+        img.save(folder / f"sample_{i}.jpg", quality=85)
+
+
+def main():
+    app = QApplication.instance() or QApplication(sys.argv)
+
+    win = MainWindow()
+    win.hide()
+
+    with tempfile.TemporaryDirectory() as td:
+        td_path = Path(td)
+        imgs = td_path / "Images"
+        _make_sample_images(imgs, n=6)
+
+        # Ensure a project exists and select it
+        pid = win.db.create_project("SELFTEST")
+        win._on_project_changed_by_id(pid)
+
+        # Run a small scan
+        win.scan_controller.start_scan(str(imgs), project_id=pid)
+        ok = _wait_until(lambda: not win.scan_controller.is_scanning(), timeout_s=30.0)
+        assert ok, "scan did not finish in time"
+
+        # Best-effort face pipeline (if available)
+        if getattr(win, "face_pipeline_service", None) is not None:
+            try:
+                win.face_pipeline_service.start(project_id=pid, mode="detect")
+            except Exception:
+                pass
+
+        # Generation gate probe
+        called = {"count": 0}
+
+        def _should_not_run(_payload=None):
+            called["count"] += 1
+
+        sig = win.scan_controller.progress_update_signal
+        connect_guarded(sig, _should_not_run, win.get_ui_generation, name="selftest_gate")
+
+        gen0 = win.get_ui_generation()
+        win.bump_ui_generation(reason="selftest simulated restart")
+        gen1 = win.get_ui_generation()
+        assert gen1 == gen0 + 1, f"generation did not increase ({gen0} -> {gen1})"
+
+        # Emit after bump, callback must be gated
+        sig.emit({"phase": "selftest", "value": 1})
+        _wait_until(lambda: True, timeout_s=0.2)
+
+        assert called["count"] == 0, "guarded callback ran after generation bump"
+
+    win.close()
+    _wait_until(lambda: True, timeout_s=0.2)
+    print("SELFTEST OK")
+
+
+if __name__ == "__main__":
+    main()
