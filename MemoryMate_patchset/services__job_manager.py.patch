--- services/job_manager.py
+++ services/job_manager.py
@@ -217,6 +217,10 @@
 
         # Worker pool (bounded concurrency)
         self._thread_pool = QThreadPool.globalInstance()
+        # Generation counter used to ignore stale worker callbacks after restart/shutdown.
+        self._generation: int = 0
+        # Set during application shutdown to prevent new job scheduling.
+        self._shutdown_requested: bool = False
         self._max_workers = min(4, self._thread_pool.maxThreadCount())
 
         # Active jobs tracking
@@ -1279,6 +1283,51 @@
             logger.warning(f"[JobManager] Failed to disable startup throttle: {e}")
 
 
+
+    # --- Shutdown, restart, generation guards ---
+    def current_generation(self) -> int:
+        return self._generation
+
+    def bump_generation(self) -> int:
+        """Increment generation and return new value.
+
+        Any UI callback from long-running workers should compare against this generation
+        to avoid touching deleted Qt objects after restart/shutdown.
+        """
+        self._generation += 1
+        return self._generation
+
+    def request_shutdown(self) -> None:
+        """Prevent new jobs from being scheduled."""
+        self._shutdown_requested = True
+
+    def can_schedule(self) -> bool:
+        return not self._shutdown_requested
+
+    def shutdown_barrier(self, *, timeout_ms: int = 10_000) -> bool:
+        """Best-effort barrier to stop accepting new jobs, request cancellation, and wait.
+
+        Returns True if the thread pool drained before timeout, else False.
+        """
+        # Stop future jobs and invalidate callbacks.
+        self.request_shutdown()
+        self.bump_generation()
+        # Ask running jobs to cancel.
+        try:
+            self.cancel_all(reason="shutdown")
+        except TypeError:
+            # Older signature without reason.
+            try:
+                self.cancel_all()
+            except Exception:
+                pass
+        except Exception:
+            pass
+        # Drain QThreadPool. QRunnables must cooperate with cancel flags.
+        try:
+            return bool(self._thread_pool.waitForDone(timeout_ms))
+        except Exception:
+            return False
 # ─────────────────────────────────────────────────────────────────────────────
 # Singleton Accessor
 # ─────────────────────────────────────────────────────────────────────────────
